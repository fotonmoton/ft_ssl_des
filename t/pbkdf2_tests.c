#include "t.h"
#include "tests.h"
#include "ft_pbkdf2.h"

static int init_hmac_sha256_ctx()
{
	t_hmac_sha256_ctx ctx;
	int i = 0;

	ft_hmac_sha256_init_ctx(&ctx);
	_is(ctx.key == NULL);
	_is(ctx.msg == NULL);
	_is(ctx.key_size == 0);
	_is(ctx.msg_size == 0);
	while(i < FT_SHA256_DIGEST_LENGTH_BYTE)
	{
		_is(ctx.out[i] == 0);
		i++;
	}
	_end("init hmac sha256 ctx");
}

static int perform_hmac_256_computation_short_key()
{
	t_hmac_sha256_ctx ctx;
	unsigned char	key[20] = {
		11, 11, 11, 11, 11,
		11, 11, 11, 11, 11,
		11, 11, 11, 11, 11,
		11, 11, 11, 11, 11,
	};
	unsigned char	msg[8] = {
		'H', 'i', ' ', 'T', 'h', 'e', 'r', 'e'
	};
	unsigned char	expected_result[FT_SHA256_DIGEST_LENGTH_BYTE] = {
		0xb0, 0x34, 0x4c, 0x61, 0xd8, 0xdb, 0x38, 0x53,
		0x5c, 0xa8, 0xaf, 0xce, 0xaf, 0x0b, 0xf1, 0x2b,
		0x88, 0x1d, 0xc2, 0x00, 0xc9, 0x83, 0x3d, 0xa7,
		0x26, 0xe9, 0x37, 0x6c, 0x2e, 0x32, 0xcf, 0xf7,
	};
	ft_hmac_sha256_init_ctx(&ctx);
	ctx.key = key;
	ctx.msg = msg;
	ctx.key_size = 20;
	ctx.msg_size = 8;
	ft_hmac_sha256(&ctx);

	int i = 0;
	while(i < FT_SHA256_DIGEST_LENGTH_BYTE)
	{
		_is(ctx.out[i] == expected_result[i]);
		i++;
	}
	_end("perform hamc sha256 computation with short key");
}

static int perform_hmac_256_computation_long_key()
{
	t_hmac_sha256_ctx ctx;
	unsigned char	key[131] = {
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
		0xaa, 0xaa, 0xaa,
	};
	unsigned char	msg[152] = {
		0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
		0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x75,
		0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x6c,
		0x61, 0x72, 0x67, 0x65, 0x72, 0x20, 0x74, 0x68,
		0x61, 0x6e, 0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b,
		0x2d, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x6b, 0x65,
		0x79, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x20,
		0x6c, 0x61, 0x72, 0x67, 0x65, 0x72, 0x20, 0x74,
		0x68, 0x61, 0x6e, 0x20, 0x62, 0x6c, 0x6f, 0x63,
		0x6b, 0x2d, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x64,
		0x61, 0x74, 0x61, 0x2e, 0x20, 0x54, 0x68, 0x65,
		0x20, 0x6b, 0x65, 0x79, 0x20, 0x6e, 0x65, 0x65,
		0x64, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65,
		0x20, 0x68, 0x61, 0x73, 0x68, 0x65, 0x64, 0x20,
		0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x62,
		0x65, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x73, 0x65,
		0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65,
		0x20, 0x48, 0x4d, 0x41, 0x43, 0x20, 0x61, 0x6c,
		0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x2e,
	};
	unsigned char	expected_result[FT_SHA256_DIGEST_LENGTH_BYTE] = {
		0x9b, 0x09, 0xff, 0xa7, 0x1b, 0x94, 0x2f, 0xcb,
		0x27, 0x63, 0x5f, 0xbc, 0xd5, 0xb0, 0xe9, 0x44,
		0xbf, 0xdc, 0x63, 0x64, 0x4f, 0x07, 0x13, 0x93,
		0x8a, 0x7f, 0x51, 0x53, 0x5c, 0x3a, 0x35, 0xe2,
	};
	ft_hmac_sha256_init_ctx(&ctx);
	ctx.key = key;
	ctx.msg = msg;
	ctx.key_size = 131;
	ctx.msg_size = 152;
	ft_hmac_sha256(&ctx);

	int i = 0;
	while(i < FT_SHA256_DIGEST_LENGTH_BYTE)
	{
		_is(ctx.out[i] == expected_result[i]);
		i++;
	}
	_end("perform hamc sha256 computation with long key");
}

int pbkdf2_tests()
{
	_should(init_hmac_sha256_ctx);
	_should(perform_hmac_256_computation_short_key);
	_should(perform_hmac_256_computation_long_key);
	return 0;
}